! Copyright 2023 Exciting developers
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!   http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
! implied. See the License for the specific language governing
! permissions and limitations under the License.

!> @file
!> This file contains types to handle world and objects generated by MAGMA

!> Module containing types to handle MAGMA
module idiel_gpu_magma_t
    
    use iso_c_binding
    use magma2
    use idiel_constants, only: i32, i64, r64

    implicit none

    private
    public  linalg_world_t

    !> Type to handle the GPU Magma queue and world
    type linalg_world_t
        !> Device id taking care of control
        integer :: device = -1
        !> GPU queue
        type(C_ptr), private  :: queue    = C_null_ptr
    contains
        procedure, public :: init, finish, is_queue_set, get_queue, syncronize, get_device
    end type linalg_world_t

contains

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                   GPU WORLD                         !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> This subroutine inits the MAGMA world and the queue
    !> @param[in] this - the GPU magma world to initialize
    !> @param[in] device - (optional) the device that should hold the queue (if not compute)
    subroutine init(this, device)
            
        class(linalg_world_t), intent(inout) :: this
        integer, optional,  intent(in)    :: device

        ! Init MAGMA
        call magma_init()
        
        ! Set device
        if (present(device)) then
            this%device = device
        else
            call magma_get_device(this%device)
        end if

        ! Init the GPU queue
        call magma_queue_create(this%device, this%queue)

    end subroutine init

    !> This subroutine finishes the MAGMA world and the queue
    !> @param[in] this - the queue to finish
    subroutine finish(this)
        
        class(linalg_world_t), intent(inout) :: this

        ! Destroy queue
        call magma_queue_destroy(this%queue)
        
        ! Destroy world
        call magma_finalize()
    
    end subroutine finish

    !> This function returns true if the queue is inited
    !> @param[in] this - the world to check if has inited queue
    pure function is_queue_set(this) result(answer)

        class(linalg_world_t), intent(in) :: this
        logical :: answer

        answer = C_associated(this%queue)

    end function is_queue_set

    !> This is a getter for the queue
    !> @param[in] this - the world object from which the queue is retrieved
    function get_queue(this) result(queue)

        class(linalg_world_t), target, intent(in) :: this
        type(C_ptr), pointer :: queue
        
        queue => this%queue 

    end function get_queue

    !> This syncronizes the queue
    !> @param[in] this - the world object from which the queue is syncronized
    subroutine syncronize(this)
        class(linalg_world_t), target, intent(in) :: this
        call magma_queue_sync(this%queue)
    end subroutine syncronize

    !> This provides device id
    !> @param[in] this - return the associated device id
    pure function get_device(this) result(device)
        class(linalg_world_t), intent(in) :: this
        integer :: device
        device = this%device
    end function get_device


end module idiel_gpu_magma_t
