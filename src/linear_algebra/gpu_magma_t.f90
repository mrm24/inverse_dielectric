! Copyright 2023 Exciting developers
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!   http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
! implied. See the License for the specific language governing
! permissions and limitations under the License.

!> @file
!> This file contains types to handle world and objects generated by MAGMA

!> Module containing types to handle MAGMA
module m_gpu_magma_t
    
    use iso_c_binding
    use magma2
    use m_constants, only: i32, i64, r64

    implicit none

    private
    public  linalg_world_t, linalg_obj_t

    !> Type to handle the GPU Magma queue and world
    type linalg_world_t
        !> Device id taking care of control
        integer :: device = -1
        !> GPU queue
        type(C_ptr), private  :: queue    = C_null_ptr
    contains
        procedure, public :: init, finish, is_queue_set, get_queue, syncronize
    end type linalg_world_t


    !> Type to handle matrices in the GPU, if GPU is not enanbled it handles normal matrices
    type linalg_obj_t
        !> The pointer of the object (matrix/vector) in the GPU
        type(C_ptr), private  :: dA    = C_null_ptr
        !> Rows
        integer, private :: n_rows    = -1
        !> Cols
        integer, private :: n_cols    = -1
        !> Element size
        integer, private :: kind_size = -1
        !> Kind of the obj
        character(len=:), allocatable, private :: kind
        !> Rank of the element
        integer, private :: rank = -1
    contains
        procedure, public :: allocate_gpu, transfer_cpu_gpu, transfer_gpu_cpu
        procedure, public :: gpu_ptr, rows, cols, get_kind
        procedure, public :: destroy 
    end type linalg_obj_t

contains

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                   GPU WORLD                         !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> This subroutine inits the MAGMA world and the queue
    !> @param[in] this - the GPU magma world to initialize
    !> @param[in] device - (optional) the device that should hold the queue (if not compute)
    subroutine init(this, device)
            
        class(linalg_world_t), intent(inout) :: this
        integer, optional,  intent(in)    :: device

        ! Init MAGMA
        call magma_init()
        
        ! Set device
        if (present(device)) then
            this%device = device
        else
            call magma_get_device(this%device)
        end if

        ! Init the GPU queue
        call magma_queue_create(this%device, this%queue)

    end subroutine init

    !> This subroutine finishes the MAGMA world and the queue
    !> @param[in] this - the queue to finish
    subroutine finish(this)
        
        class(linalg_world_t), intent(inout) :: this

        ! Destroy queue
        call magma_queue_destroy(this%queue)
        
        ! Destroy world
        call magma_finalize()
    
    end subroutine finish

    !> This function returns true if the queue is inited
    !> @param[in] this - the world to check if has inited queue
    pure function is_queue_set(this) result(answer)

        class(linalg_world_t), intent(in) :: this
        logical :: answer

        answer = C_associated(this%queue)

    end function is_queue_set

    !> This is a getter for the queue
    !> @param[in] this - the world object from which the queue is retrieved
    function get_queue(this) result(queue)

        class(linalg_world_t), target, intent(in) :: this
        type(C_ptr), pointer :: queue
        
        queue => this%queue 

    end function get_queue

    !> This syncronizes the queue
    !> @param[in] this - the world object from which the queue is syncronized
    subroutine syncronize(this)
        class(linalg_world_t), target, intent(in) :: this
        call magma_queue_sync(this%queue)
    end subroutine syncronize

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                   UTILS                             !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> This polymorphic function returns the size of this kind in bytes (as Intel does not have it)
    !> @param[in] this - the element from which the sizeof is asked
    !> @result kind_size - the size of the kind of this in bytes
    pure function sizeof_this(this) result(kind_size)
                
        class(*), intent(in) :: this(..)
        integer(i32) :: kind_size

        kind_size = STORAGE_SIZE(this) / STORAGE_SIZE('1')

    end function sizeof_this

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !                   GPU OBJECTS                       !
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> This deallocates the object in the GPU 
    !> @param[in] this - gpu_matrix object to destroy
    subroutine destroy(this, queue)
        
        class(linalg_obj_t), intent(inout) :: this
        type(C_ptr), intent(inout)      :: queue

        integer :: info

        if (C_associated(this%dA)) then
            info = magma_free(this%dA)
            if (info /= 0) error stop "linalg_obj_t%destroy: Error in freeing GPU memory"
        end if
        
        this%n_rows    = -1
        this%n_cols    = -1
        this%kind_size = -1
        this%rank      = -1

    end subroutine destroy

    !> This subroutine allocates the matrix in the GPU
    !> @param[in] this - gpu_matrix object for which GPU memory is allocated
    !> @param[in] A    - object to mold the allocation
    subroutine allocate_gpu(this, A)
        
        class(linalg_obj_t), intent(inout)  :: this
        class(*), contiguous, intent(in) :: A(..)

        integer :: info
        integer(C_size_t) :: nbytes

        ! Select the rank of the object
        select rank(A)
            rank(1)
                this%rank   = rank(A)
                this%n_rows = size(A,1)
                this%n_cols = 1 
                
                select type(A)
                    type is (real(r64))
                        this%kind = 'r64'
                    type is (complex(r64))
                        this%kind = 'c64'
                    class default
                        error stop "linalg_obj_t%allocate: Error in kind, only real and complex (r64) are accepted"
                end select

            rank(2)
                this%rank   = rank(A)
                this%n_rows = size(A,1)
                this%n_cols = size(A,2)

                select type(A)
                    type is (real(r64))
                        this%kind = 'r64'
                    type is (complex(r64))
                        this%kind = 'c64'
                    class default
                        error stop "linalg_obj_t%allocate: Error in kind, only real and complex (r64) are accepted"
                end select

            rank default
                error stop "linalg_obj_t%allocate: Error in rank, only 1 and 2 are accepted"
        end select

        ! Allocating memory in the GPU
        this%kind_size = sizeof_this(A)

        nbytes = int(this%n_cols * this%n_rows * this%kind_size, C_size_t)
        info = magma_malloc(this%dA, nbytes)

        if (info /= 0) error stop "linalg_obj_t%allocate: Error in allocating GPU memory"

    end subroutine allocate_gpu

    !> This subroutine fills a GPU matrix (sync)
    !> @param[in] this - gpu_matrix object for which GPU memory is allocated
    !> @param[in] A    - object to transfer to the GPU
    !> @param[in] queue  - queue for GPU operations 
    subroutine transfer_cpu_gpu(this, A, queue)
        
        class(linalg_obj_t), intent(inout)       :: this
        type(*), contiguous, intent(in), target :: A(..)
        type(C_ptr), intent(inout)               :: queue

        ! Select the appropiate case
        select case(this%rank)
            case(1)
                call magma_setvector(this%n_rows, this%kind_size, C_loc(A), 1, this%dA, 1, queue)
            case(2)
                call magma_setmatrix(this%n_rows, this%n_cols, this%kind_size, C_loc(A), this%n_rows, this%dA, this%n_rows, queue)
            case default
                error stop "linalg_obj_t%fill: Error filling matrix"
        end select
    end subroutine transfer_cpu_gpu

    !> This subroutine retrieve a GPU element to the CPU (sync)
    !> @param[in] this - gpu_matrix object for which GPU memory is allocated
    !> @param[in] A    - object to which the element from the GPU would be transfered to
    !> @param[in] queue  - queue for GPU operations 
    subroutine transfer_gpu_cpu(this, A, queue)
        
        class(linalg_obj_t), intent(inout)          :: this
        type(*), contiguous, intent(inout), target :: A(..)
        type(C_ptr), intent(inout)                  :: queue

        ! Select the appropiate case
        select case(this%rank)
            case(1)
                call magma_getvector(this%n_rows, this%kind_size, this%dA, 1, C_loc(A), 1, queue)
            case(2)
                call magma_getmatrix(this%n_rows, this%n_cols, this%kind_size, this%dA, this%n_rows, C_loc(A), this%n_rows, queue)
            case default
                error stop "linalg_obj_t%fill: Error filling matrix"
        end select

    end subroutine transfer_gpu_cpu

    !> This function retrieves the pointer to the GPU data
    !> @param[in] this - the obj from which retrieve the pointer to GPU data
    pure type(C_ptr) function gpu_ptr(this)
        class(linalg_obj_t), intent(in) :: this
        gpu_ptr = this%dA 
    end function gpu_ptr

    !> This function retrieves the number of rows
    !> @param[in] this - the obj from which retrieve info
    pure integer function rows(this)       
        class(linalg_obj_t), intent(in) :: this
        rows = this%n_rows
    end function rows

    !> This function retrieves the number of cols
    !> @param[in] this - the obj from which retrieve info
    pure integer function cols(this)       
        class(linalg_obj_t), intent(in) :: this
        cols = this%n_cols
    end function cols

    !> This function retrieves the number of cols
    !> @param[in] this - the obj from which retrieve info
    pure function get_kind(this) result(answer)
        class(linalg_obj_t), intent(in) :: this
        character(len=:), allocatable :: answer
        answer = this%kind
    end function get_kind

    
end module m_gpu_magma_t
